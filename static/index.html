<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LiDAR Area Monitor — Web</title>
<style>
  :root {
    --bg: #0f1221; --panel: #171a2b; --accent: #ff8c00; --text: #e9edf1; --muted: #98a2b3; --grid: #1f2340;
    --ok: #00d084; --uwb: #20f3c8; --bbox: #64aaff; --bbox-verified:#11e9a8; --vel:#fff27e; --lidar:#ffe08a; --antenna:#7ee787;
    --near:#72e3ff; /* ciano per "vicino al TAG" (by_radius) */
  }
  * { box-sizing: border-box; }
  body { margin:0; background: linear-gradient(180deg,#0b0e1a,#10132a); color:var(--text);
         font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  header { display:flex; align-items:center; justify-content:space-between; padding:12px 16px;
           background:#0b0e1a; border-bottom:1px solid #1d2242; position:sticky; top:0; z-index:10; }
  h1 { font-size:18px; margin:0; letter-spacing:.3px; }
  .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  button { background:#22264a; color:var(--text); border:1px solid #2d3360; border-radius:10px; padding:8px 12px;
           font-weight:600; cursor:pointer; transition:transform .06s ease, background .2s ease, border .2s ease; }
  button:hover { background:#2a2f5a; } button:active { transform:scale(.98); }
  .danger { border-color:#3a2433; background:#2d1a24; } .danger:hover { background:#361f2b; }
  .ok { border-color:#1e3a2a; background:#16261d; } .ok:hover { background:#1b2e23; }
  .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-size:11px; margin-left:6px; }
  .pill.ok { background:rgba(0,200,83,.15); color:#9af7bf; border:1px solid rgba(0,200,83,.35); }
  .pill.warn { background:rgba(255,213,79,.15); color:#ffe08a; border:1px solid rgba(255,213,79,.35); }
  #wrap { display:grid; grid-template-columns: 1fr 360px; gap:12px; padding:12px; }
  #panel { background:var(--panel); border:1px solid #23264a; border-radius:14px; padding:8px; }
  #canvas { width:100%; height: calc(100vh - 140px); background:#0d1022; border-radius:12px; display:block; touch-action:none; }
  #side { background:var(--panel); border:1px solid #23264a; border-radius:14px; padding:12px; }
  #list { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; line-height:1.35;
          max-height: calc(100vh - 180px); overflow:auto; }
  .row { padding:6px 8px; border-radius:8px; border:1px solid transparent; margin-bottom:6px; display:flex; gap:8px; align-items:center; }
  .row.verified { border-color: rgba(17,233,168,.35); background: rgba(17,233,168,.08); }
  .row.near:not(.verified) { border-color: rgba(114,227,255,.35); background: rgba(114,227,255,.08); }
  .id-badge { font-weight:700; padding:1px 6px; border-radius:999px; border:1px solid #2a2f5a; background:#1b1f38; }
  .id-badge.near { color: var(--near); border-color: rgba(114,227,255,.55); }
  .id-badge.verified { color: var(--bbox-verified); border-color: rgba(17,233,168,.55); }
  .meta { color:#cbd5e1; }
  .badges { display:flex; gap:8px; margin-top:6px; color:#cbd5e1; font-size:12px; }
  .badge { background:#1b1f38; border:1px solid #2a2f5a; border-radius:999px; padding:2px 8px; }
  @media (max-width:1100px){ #wrap { grid-template-columns: 1fr; } #side { order:-1; } }
</style>
</head>
<body>
<header>
  <h1>LiDAR Area Monitor — Web <span id="wsState" class="pill warn">WS: connecting…</span></h1>
  <div class="controls">
    <button id="btnAdd" class="ok">Aggiungi area</button>
    <button id="btnSet">Imposta come unica area</button>
    <button id="btnClear" class="danger">Cancella aree</button>
  </div>
</header>

<div id="wrap">
  <div id="panel">
    <canvas id="canvas"></canvas>
    <div class="badges">
      <div class="badge">Aree: <span id="bAreas">0</span></div>
      <div class="badge">Tracce: <span id="bTracks">0</span></div>
      <div class="badge">Tag: <span id="bTags">0</span></div>
    </div>
    <div style="margin-top:6px; font-size:12px; color:#98a2b3">
      • Grid 10 cm • Pan = <b>SPACE + drag</b> • Zoom = <b>wheel</b> • Reset vista = <b>R</b> o <b>0</b><br/>
      • Aree = arancione • LiDAR (assi) = giallo • Antenna = verde • TAG = turchese • BBOX verificata = verde acqua • Vicino (raggio) = ciano
    </div>
  </div>
  <div id="side">
    <div style="color:#98a2b3; font-size:12px">
      Clicca nel canvas per disegnare punti (quando non stai facendo pan). Doppio-click/Invio chiude. ESC annulla.
    </div>
    <hr style="border-color:#23264a"/>
    <div id="list"></div>
  </div>
</div>

<script>
(() => {
  // ---------- Canvas & camera ----------
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  // Camera: centro in (0,0) al reset, scala = px per metro
  const cam = { x: 0, y: 0, scale: 300 }; // ~3.3px/cm
  const LIMIT = { minScale: 60, maxScale: 1400 }; // 0.06..1.4 kpx/m

  function resize(){
    const w = Math.max(200, canvas.clientWidth|0);
    const h = Math.max(200, canvas.clientHeight|0);
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    dirty = true;
  }
  window.addEventListener('resize', resize);

  // Mondo ⇄ schermo
  function w2sXY(x,y){
    return [
      (x - cam.x) * cam.scale + canvas.width/2,
      canvas.height/2 - (y - cam.y) * cam.scale
    ];
  }
  function s2wXY(sx,sy){
    return [
      (sx - canvas.width/2) / cam.scale + cam.x,
      (canvas.height/2 - sy) / cam.scale + cam.y
    ];
  }

  // ---------- Stato ----------
  let areas = [];
  let tracks = [];
  let tags = [];
  let refs = null;
  let drawing = [];

  // param verifica: aggiornato da `refs` WS
  const VERIFY = { mode: 'both', radius: 0.25, margin: 0.02 };

  // ---------- REST ----------
  async function fetchAreas(){
    const res = await fetch('/areas');
    const data = await res.json();
    areas = data.areas || [];
    document.getElementById('bAreas').textContent = areas.length;
    dirty = true;
  }
  async function postArea(coords){ await fetch('/areas',{method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({coords})}); await fetchAreas(); }
  async function putArea(coords){ await fetch('/areas',{method:'PUT',  headers:{'Content-Type':'application/json'}, body:JSON.stringify({coords})}); await fetchAreas(); }
  async function clearAreas(){ await fetch('/areas',{method:'DELETE'}); areas=[]; document.getElementById('bAreas').textContent='0'; dirty = true; }

  // ---------- WebSocket unificato ----------
  const wsState = document.getElementById('wsState');
  function setWsState(text, cls){ wsState.textContent=text; wsState.className='pill '+(cls||''); }
  let ws;
  function openWS(){
    const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
    ws = new WebSocket(`${proto}://${location.host}/ws`);
    ws.onopen  = () => setWsState('WS: connected', 'ok');
    ws.onclose = () => { setWsState('WS: disconnected', 'warn'); setTimeout(openWS, 1000); };
    ws.onerror = () => setWsState('WS: error', 'warn');
    ws.onmessage = (ev) => {
      try{
        const msg = JSON.parse(ev.data);
        if (msg.type === 'tracks'){
          tracks = msg.data.tracks || [];
          document.getElementById('bTracks').textContent = tracks.length;
          // se non abbiamo assocs recenti, fai fallback locale
          if (verifiedByTrack.size === 0) computeVerifications();
          renderList(); dirty = true;
        } else if (msg.type === 'uwb'){
          tags = (msg.data && msg.data.tags) ? msg.data.tags : [];
          document.getElementById('bTags').textContent = tags.length;
          if (verifiedByTrack.size === 0) computeVerifications();
          renderList(); dirty = true;
        } else if (msg.type === 'refs'){
          refs = msg.data || null;
          if (refs && refs.assoc){
            if (typeof refs.assoc.radius === 'number') VERIFY.radius = refs.assoc.radius;
            if (typeof refs.assoc.bbox_margin === 'number') VERIFY.margin = refs.assoc.bbox_margin;
            if (typeof refs.assoc.mode === 'string') VERIFY.mode = refs.assoc.mode;
          }
          dirty = true;
        } else if (msg.type === 'assocs'){
          applyAssocs(msg.data); // server → più fedele al nodo
          renderList(); dirty = true;
        }
      } catch {}
    };
  }

  // ---------- Verifiche da server + fallback locale ----------
  // verifiedByTrack[id] = { ok, tagId, dist, byR, byB }
  const verifiedByTrack = new Map();

  function applyAssocs(payload){
    verifiedByTrack.clear();
    if (!payload || !Array.isArray(payload.assocs)) return;
    for (const a of payload.assocs){
      verifiedByTrack.set(a.track_id, {
        ok: !!a.verified,
        tagId: (a.tag_id == null ? null : String(a.tag_id)),
        dist: (typeof a.distance === 'number') ? a.distance : (typeof a.dist === 'number' ? a.dist : Infinity),
        byR: !!a.by_radius,
        byB: !!a.by_bbox,
      });
    }
  }

  function computeVerifications(){
    // fallback locale quando non arriva ancora /assocs
    verifiedByTrack.clear();
    if (!tracks.length || !tags.length) return;
    for (const t of tracks){
      let best = {dist: Infinity, tag: null};
      for (const g of tags){
        const d = Math.hypot((t.x - g.x), (t.y - g.y));
        if (d < best.dist){ best = {dist:d, tag:g}; }
      }
      let byR = (best.dist <= VERIFY.radius);
      let byB = false;
      if (t.bbox){
        const m=VERIFY.margin, [minx,miny,maxx,maxy]=t.bbox;
        byB = (best.tag && (minx-m<=best.tag.x&&best.tag.x<=maxx+m && miny-m<=best.tag.y&&best.tag.y<=maxy+m));
      }
      const mode = (VERIFY.mode||'both').toLowerCase();
      const ok = (mode==='centroid_radius') ? byR : (mode==='bbox') ? byB : (byR||byB);
      if (best.tag) verifiedByTrack.set(t.id, { ok, tagId: best.tag.id, dist: best.dist, byR, byB });
    }
  }

  // ---------- Interazione: pan/zoom + disegno poligoni ----------
  let spaceDown = false, panning = false, panStart = null, dirty = true;
  window.addEventListener('keydown', (e)=>{
    if (e.code === 'Space') { spaceDown = true; }
    if ((e.key === '0') || (e.key.toLowerCase() === 'r')) { resetView(); }
    if (e.key === 'Enter' && drawing.length>=3) finalizePolygon();
    if (e.key === 'Escape'){ drawing=[]; dirty = true; }
  });
  window.addEventListener('keyup', (e)=>{ if (e.code === 'Space') spaceDown = false; });

  canvas.addEventListener('pointerdown', (e)=>{
    canvas.setPointerCapture(e.pointerId);
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) * DPR;
    const sy = (e.clientY - rect.top) * DPR;

    if (spaceDown || e.button===1 || e.button===2){ // pan
      panning = true; panStart = { sx, sy, cx: cam.x, cy: cam.y };
    } else {
      // add point to drawing polygon
      const p = s2wXY(sx, sy);
      drawing.push(p); dirty = true;
    }
  });
  canvas.addEventListener('pointermove', (e)=>{
    if (!panning) return;
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) * DPR;
    const sy = (e.clientY - rect.top) * DPR;
    const dx = (sx - panStart.sx) / cam.scale;
    const dy = (sy - panStart.sy) / cam.scale;
    cam.x = panStart.cx - dx;
    cam.y = panStart.cy + dy;
    dirty = true;
  });
  canvas.addEventListener('pointerup', ()=>{ panning=false; panStart=null; });

  canvas.addEventListener('dblclick', finalizePolygon);
  function finalizePolygon(){ if (drawing.length<3) return; dirty = true; }

  // Zoom sul cursore
  canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) * DPR;
    const sy = (e.clientY - rect.top) * DPR;
    const [wx, wy] = s2wXY(sx, sy);
    const factor = Math.exp(-e.deltaY * 0.0015);
    const old = cam.scale;
    cam.scale = Math.max(LIMIT.minScale, Math.min(LIMIT.maxScale, cam.scale * factor));
    // Mantieni il punto sotto il mouse fermo
    const [sx2, sy2] = w2sXY(wx, wy);
    cam.x += (wx - s2wXY(sx2, sy2)[0]);
    cam.y += (wy - s2wXY(sx2, sy2)[1]);
    dirty = true;
  }, { passive:false });

  function resetView(){
    cam.x = 0; cam.y = 0; cam.scale = 300; dirty = true;
  }

  // Bottoni aree
  document.getElementById('btnAdd').onclick  = async ()=>{ if (drawing.length<3) return alert('Aggiungi almeno 3 punti.'); await postArea(drawing); drawing=[]; dirty = true; };
  document.getElementById('btnSet').onclick  = async ()=>{ if (drawing.length<3) return alert('Aggiungi almeno 3 punti.'); await putArea(drawing);  drawing=[]; dirty = true; };
  document.getElementById('btnClear').onclick= async ()=>{ await clearAreas(); };

  // ---------- Render ----------
  function drawGrid(){
    const W=canvas.width,H=canvas.height;

    // sfondo
    ctx.fillStyle='#0d1022';
    ctx.fillRect(0,0,W,H);

    // step in px per 0.1 m (10cm)
    const stepPx = 0.1 * cam.scale;
    if (stepPx < 6) return; // troppo fitto: evita sprechi

    // offset delle linee che attraversano il centro (0,0)
    const [cx, cy] = w2sXY(0,0);

    ctx.lineWidth = 1*DPR;
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
    ctx.beginPath();

    // verticali
    for (let x=cx; x<=W; x+=stepPx) { ctx.moveTo(x,0); ctx.lineTo(x,H); }
    for (let x=cx-stepPx; x>=0; x-=stepPx) { ctx.moveTo(x,0); ctx.lineTo(x,H); }
    // orizzontali
    for (let y=cy; y<=H; y+=stepPx) { ctx.moveTo(0,y); ctx.lineTo(W,y); }
    for (let y=cy-stepPx; y>=0; y-=stepPx) { ctx.moveTo(0,y); ctx.lineTo(W,y); }
    ctx.stroke();

    // Assi X/Y più spessi
    ctx.lineWidth = 2*DPR;
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.beginPath();
    ctx.moveTo(0,cy); ctx.lineTo(W,cy);
    ctx.moveTo(cx,0); ctx.lineTo(cx,H);
    ctx.stroke();

    // Tacche metriche ogni 0.5 m
    const bigStep = 0.5 * cam.scale;
    if (bigStep >= 18){
      ctx.lineWidth = 2*DPR;
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.beginPath();
      for (let x=cx; x<=W; x+=bigStep){ ctx.moveTo(x,cy-6*DPR); ctx.lineTo(x,cy+6*DPR); }
      for (let x=cx-bigStep; x>=0; x-=bigStep){ ctx.moveTo(x,cy-6*DPR); ctx.lineTo(x,cy+6*DPR); }
      for (let y=cy; y<=H; y+=bigStep){ ctx.moveTo(cx-6*DPR,y); ctx.lineTo(cx+6*DPR,y); }
      for (let y=cy-bigStep; y>=0; y-=bigStep){ ctx.moveTo(cx-6*DPR,y); ctx.lineTo(cx+6*DPR,y); }
      ctx.stroke();
    }
  }

  function drawAreas(){
    for (const a of areas){
      const [minx,miny,maxx,maxy]=a.bounds;
      const [fx,fy]=w2sXY(minx,miny); const [tx,ty]=w2sXY(maxx,maxy);
      ctx.fillStyle='rgba(255,140,0,0.18)';
      ctx.fillRect(Math.min(fx,tx), Math.min(fy,ty), Math.abs(tx-fx), Math.abs(ty-fy));
      // contorno poligono
      const coords = (a.coords||[]);
      if (coords.length){
        ctx.strokeStyle='rgba(255,140,0,0.95)'; ctx.lineWidth=2*DPR; ctx.beginPath();
        coords.forEach((p,i)=>{ const [sx,sy]=w2sXY(p[0],p[1]); if (i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy); });
        const [sx0,sy0]=w2sXY(coords[0][0],coords[0][1]); ctx.lineTo(sx0,sy0); ctx.stroke();
      }
    }
  }

  function drawRefs(){
    // LiDAR assi centered in (0,0)
    const L = (refs && refs.lidar && refs.lidar.axis_len) ? refs.lidar.axis_len : 0.35;
    const [oX,oY] = w2sXY(0,0); const [xX,xY] = w2sXY(L,0); const [yX,yY] = w2sXY(0,L*0.6);
    ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--lidar'); ctx.lineWidth=2*DPR;
    ctx.beginPath(); ctx.moveTo(oX,oY); ctx.lineTo(xX,xY); ctx.moveTo(oX,oY); ctx.lineTo(yX,yY); ctx.stroke();
    drawArrowHead(oX,oY,xX,xY,getComputedStyle(document.documentElement).getPropertyValue('--lidar'));

    // Antenna: freccia da (ax,ay) verso yaw
    if (refs && refs.antenna){
      const ax=refs.antenna.x||0, ay=refs.antenna.y||0;
      const AL = refs.antenna.axis_len || 0.35;
      const ex = ax + AL*Math.cos(refs.antenna.yaw_rad);
      const ey = ay + AL*Math.sin(refs.antenna.yaw_rad);
      const [sx1,sy1] = w2sXY(ax,ay); const [sx2,sy2] = w2sXY(ex,ey);
      ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--antenna');
      ctx.lineWidth=2*DPR; ctx.beginPath(); ctx.moveTo(sx1,sy1); ctx.lineTo(sx2,sy2); ctx.stroke();
      drawArrowHead(sx1,sy1,sx2,sy2,getComputedStyle(document.documentElement).getPropertyValue('--antenna'));
    }
  }

  function drawArrowHead(sx1,sy1,sx2,sy2,color){
    const ang = Math.atan2(sy2-sy1,sx2-sx1);
    const ah = 10*DPR, aw = 5*DPR;
    ctx.fillStyle = color || '#fff';
    ctx.beginPath();
    ctx.moveTo(sx2, sy2);
    ctx.lineTo(sx2 - ah*Math.cos(ang) + aw*Math.sin(ang), sy2 - ah*Math.sin(ang) - aw*Math.cos(ang));
    ctx.lineTo(sx2 - ah*Math.cos(ang) - aw*Math.sin(ang), sy2 - ah*Math.sin(ang) + aw*Math.cos(ang));
    ctx.closePath(); ctx.fill();
  }

  function drawTags(){
    for (const t of tags){
      const [sx,sy]=w2sXY(t.x,t.y);
      ctx.fillStyle='rgba(32,243,200,0.95)';
      ctx.beginPath(); ctx.arc(sx,sy,4*DPR,0,Math.PI*2); ctx.fill();
      if (cam.scale > 120){
        ctx.fillStyle='#e9edf1'; ctx.font=`${12*DPR}px ui-monospace, Menlo, monospace`;
        ctx.fillText(`TAG ${t.id}`, sx + 8*DPR, sy - 8*DPR);
      }
    }
  }

  function drawTracks(){
    const velColor = getComputedStyle(document.documentElement).getPropertyValue('--vel');
    for (const t of tracks){
      const [sx,sy]=w2sXY(t.x,t.y);
      const sp = (t.speed ?? Math.hypot(t.vx||0,t.vy||0));
      const ver = verifiedByTrack.get(t.id);

      // centroide
      const centroidColor = (ver && ver.ok) ? 'rgba(17,233,168,0.95)'
                           : (sp>0.02 ? 'rgba(64,227,120,0.95)' : 'rgba(200,200,200,0.4)');
      ctx.fillStyle = centroidColor;
      ctx.beginPath(); ctx.arc(sx,sy,5*DPR,0,Math.PI*2); ctx.fill();

      // freccia velocità
      if (sp>0.01){
        const L = 0.6;
        const ex = t.x + (t.vx||0)*L, ey = t.y + (t.vy||0)*L;
        const [sx2,sy2] = w2sXY(ex,ey);
        ctx.strokeStyle=velColor; ctx.lineWidth=2*DPR;
        ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(sx2,sy2); ctx.stroke();
        drawArrowHead(sx,sy,sx2,sy2,velColor);
      }

      // bbox
      if (t.bbox){
        const [minx,miny,maxx,maxy]=t.bbox;
        const [bx,by]=w2sXY(minx,miny); const [tx,ty]=w2sXY(maxx,maxy);
        ctx.strokeStyle= (ver && ver.ok)
          ? getComputedStyle(document.documentElement).getPropertyValue('--bbox-verified')
          : getComputedStyle(document.documentElement).getPropertyValue('--bbox');
        ctx.lineWidth=2*DPR;
        ctx.strokeRect(Math.min(bx,tx), Math.min(by,ty), Math.abs(tx-bx), Math.abs(ty-by));
      }

      // link tratteggiato al tag verificante
      if (ver && ver.ok && ver.tagId != null){
        const tg = tags.find(g=>String(g.id)===String(ver.tagId));
        if (tg){
          const [gx,gy]=w2sXY(tg.x,tg.y);
          ctx.setLineDash([6*DPR, 6*DPR]); ctx.strokeStyle='rgba(17,233,168,0.6)'; ctx.lineWidth=1*DPR;
          ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(gx,gy); ctx.stroke(); ctx.setLineDash([]);
        }
      }

      // label
      if (cam.scale > 120){
        ctx.fillStyle='#e9edf1'; ctx.font=`${12*DPR}px ui-monospace, Menlo, monospace`;
        const verTxt = (ver && ver.ok) ? ` ✓ TAG ${ver.tagId}` : '';
        ctx.fillText(`ID ${t.id}${verTxt}`, sx + 8*DPR, sy - 8*DPR);
      }
    }
  }

  function drawDrawing(){
    if (drawing.length===0) return;
    ctx.strokeStyle='rgba(255,140,0,0.95)'; ctx.lineWidth=2*DPR; ctx.beginPath();
    drawing.forEach((p,i)=>{ const [sx,sy]=w2sXY(p[0],p[1]); if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy); });
    ctx.stroke();
  }

  function draw(){
    drawGrid(); drawAreas(); drawRefs(); drawTags(); drawTracks(); drawDrawing();
  }

  // ---------- Lista laterale ----------
  function renderList(){
    const box=document.getElementById('list');
    const frag = document.createDocumentFragment();
    box.textContent = '';
    for (const t of tracks){
      const sp=(t.speed ?? Math.hypot(t.vx||0,t.vy||0)).toFixed(2);
      const ver = verifiedByTrack.get(t.id);
      const row=document.createElement('div');
      const near = !!(ver && ver.byR);
      const ok = !!(ver && ver.ok);
      row.className = 'row' + (ok ? ' verified' : '') + (near ? ' near' : '');

      const idBadge = document.createElement('span');
      idBadge.className = 'id-badge' + (ok ? ' verified' : (near ? ' near' : ''));
      idBadge.textContent = `ID ${t.id}`;

      const meta = document.createElement('span');
      meta.className = 'meta';
      const tagTxt = ver && ver.tagId != null ? `  TAG ${ver.tagId} @${(ver.dist ?? 0).toFixed(2)}m` : '';
      meta.textContent = ` x=${t.x.toFixed(2)}  y=${t.y.toFixed(2)}  |v|=${sp} m/s${ok ? '  ✓' : ''}${tagTxt}`;

      row.appendChild(idBadge);
      row.appendChild(meta);
      frag.appendChild(row);
    }
    box.appendChild(frag);
  }

  // ---------- RAF loop con dirty flag ----------
  let lastDraw = 0;
  function loop(ts){
    // limita a ~30 FPS e solo quando dirty
    if (dirty && (ts - lastDraw) > 33){
      lastDraw = ts; dirty = false; draw();
    }
    requestAnimationFrame(loop);
  }

  // init
  resize();
  fetchAreas();
  openWS();
  computeVerifications(); // fallback iniziale (vuoto se non ci sono dati)
  renderList();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
